\documentclass[12pt,journal,compsoc]{IEEEtran}
\usepackage[utf8]{inputenc}
\usepackage[ngerman]{babel}
%\usepackage{tikz, tikzscale, adjustbox,enumerate, tabularx, multirow, booktabs}
\usepackage{graphicx, tabularx, booktabs, enumerate, multirow}
\usepackage{cite, textcomp}

\usepackage{listings}
\lstset{
  language=C,
  basicstyle=\ttfamily\small,
  keywordstyle=\color{blue}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  commentstyle=\color{green}\ttfamily\normalsize,
  breakatwhitespace=false,
  breaklines=true
}


\makeatletter
{\obeylines\gdef\bt@eol{^^M}}
\newenvironment{breakabletexttt}
  {\ttfamily\hfuzz=0.4em
   \list{}{\leftmargin=2em
           \itemindent=-\leftmargin
           \listparindent=-\leftmargin
           \parsep=0pt}
   \item\relax\obeylines\obeyspaces\expandafter\breakable@texttt\@gobble}
  {\endlist}
\def\breakable@texttt{\futurelet\@let@token\breakable@texttti}
\def\breakable@texttti#1{%
  \ifx\@let@token\end
  \expandafter\end
  \else
    \expandafter\ifx\bt@eol\@let@token
      \par
    \else
      \string#1\hskip1sp
    \fi
    \expandafter\breakable@texttt
  \fi}
\makeatother



\usepackage{tikz, tikzscale} % tiks für Zeichnungen

\usepackage[europeanresistors,europeaninductors,arrowmos]{circuitikz}
\usepackage{amsmath}

%\usepackage[siunitx]{circuitikz}
%\usepackage[ngerman]{varioref}% Definiert variable Referenzierungen
%\usetikzlibrary{dsp,chains}

\providecommand{\PSforPDF}[1]{#1}
\setcounter{secnumdepth}{1}

% NOTE: PDF hyperlink and bookmark features are not required in IEEE
%       papers and their use requires extra complexity and work.
% *** IF USING HYPERREF BE SURE AND CHANGE THE EXAMPLE PDF ***
% *** TITLE/SUBJECT/AUTHOR/KEYWORDS INFO BELOW!!           ***
\newcommand\MYhyperrefoptions{bookmarks=true,bookmarksnumbered=true,
pdfpagemode={UseOutlines},plainpages=false,pdfpagelabels=true,
colorlinks=true,linkcolor={black},citecolor={black},pagecolor={black},
urlcolor={black},

pdftitle={DIY Wordclock},
pdfsubject={Wordclock},
pdfauthor={Christof Pfannenmüller}}




% correct bad hyphenation here
%\hyphenation{op-tical net-works semi-conduc-tor}


\begin{document} %----------------------------------------------------------------------------Beginn des Dokuments
%
% paper title
% can use linebreaks \\ within to get better formatting as desired
\title{DIY Wordclock}

\author{Christof Pfannenmüller}% <-this % stops a space



  % for Computer Society papers, we must declare the abstract and index terms
  % PRIOR to the title within the \IEEEcompsoctitleabstractindextext IEEEtran
  % command as these need to go into the title area created by \maketitle.
%  \IEEEcompsoctitleabstractindextext{%
%  \begin{abstract}
  %\boldmath
  %The abstract goes here.
%  \end{abstract}
  % IEEEtran.cls defaults to using nonbold math in the Abstract.
  % This preserves the distinction between vectors and scalars. However,
  % if the journal you are submitting to favors bold math in the abstract,
  % then you can use LaTeX's standard command \boldmath at the very start
  % of the abstract to achieve this. Many IEEE journals frown on math
  % in the abstract anyway. In particular, the Computer Society does
  % not want either math or citations to appear in the abstract.

  % Note that keywords are not normally used for peerreview papers.
%  \begin{IEEEkeywords}
%  Computer Society, IEEEtran, journal, \LaTeX, paper, template.
%  \end{IEEEkeywords}}


% make the title area
\maketitle


% To allow for easy dual compilation without having to reenter the
% abstract/keywords data, the \IEEEcompsoctitleabstractindextext text will
% not be used in maketitle, but will appear (i.e., to be "transported")
% here as \IEEEdisplaynotcompsoctitleabstractindextext when compsoc mode
% is not selected <OR> if conference mode is selected - because compsoc
% conference papers position the abstract like regular (non-compsoc)
% papers do!
\IEEEdisplaynotcompsoctitleabstractindextext
% \IEEEdisplaynotcompsoctitleabstractindextext has no effect when using
% compsoc under a non-conference mode.


% For peer review papers, you can put extra information on the cover
% page as needed:
% \ifCLASSOPTIONpeerreview
% \begin{center} \bfseries EDICS Category: 3-BBND \end{center}
% \fi
%
% For peerreview papers, this IEEEtran command inserts a page break and
% creates the second title. It will be ignored for other modes.
%\IEEEpeerreviewmaketitle

%----------------------------------------------------------------------------------------------Beginn des  eigentlichen Textes

\section{Einführung}

\IEEEPARstart{W}{ordclocks} haben in der Bastler oder DIY-Szene eine große Verbreitung und bergen eine gewisse Faszination. 


Grundsätzlich sind die alle Wordclocks sehr ähnlich aufgebaut. Fast immer wird eine Frontplatte auf welcher die Buchstaben passend angeordnet sind, durch eine Matrix an LEDs von hinten erleuchtet. Dadurch, dass nur die zur aktuellen Stunde passenden   Wörter erleuchtet sind, stechen diese aus den, auf den ersten Blick verwirrend angeordneten, Buchstaben der Frontplatte hervor. Wichtig bei einer Wordclock ist auch, dass jede LED nur den für sie vorgesehen Buchstaben der Frontplatte beleuchtet und nicht zu einem Teil auch die benachbarten Buchstaben, da dies den Effekt des Hervorscheinens der erleuteten Buchstaben vor den dunkleren minimieren würde. Dafür wird meist eine so genannte Zwischenplatte angebracht, so kann sichergestellt werden, das das Licht  einer LED  nicht  auf einen anderen Teil der Frontplatte scheint, da es durch die Zwischenplatte abgeschirmt wird.
Wordclocks wurden bereits in vielen verschiedenen Sprachen erstellt, wobei  grundsätzlich jede Sprache möglich ist. Die einzige Bedingung ist, dass es möglich ist alle Wörter die zum "schreiben" der Uhrzeit notwendig sind, auf der Frontplatte anzuordnen. Dabei ist jedoch wichtig, dass die Reihenfolge der Wörter so gewählt wird, das jede mögliche Uhrzeit auch dargestellt werden kann, ohne aber ein Wort doppelt unterbringen zu müssen und trotzdem die Reihenfolge der Wörter dem Sprachgebrauch entspricht. In diesem Zusammenhang ist etwa die Darstellung der Zeit 15:45 interessant, denn je nach Wohnort werden für diese verschiedene Zeiten im Umgang verwendet. Vor allem in Sachsen, Thüringen und Franken wird die Bezeichnung "dreviertel vier" verwendet, in Norddeutschland dagegen eher "viertel vor sechs". Solche Feinheiten müssen also berücksichtigt werden,  bei "viertel nach drei" bzw. "viertel vier" verhält es sich ähnlich.

\section{Anforderungen}
Die Wordclock sollte vor allem - im Gegensatz zu den meisten anderen - kleiner ausgelegt sein und nicht zum Aufhängen an der Wand gedacht sein, sondern als modulare kleine Tischuhr, die bei Einbau einer Alarmfunktion, auch als Wecker dienen kann.
qlocktwo als vorbild

Um zunächst einen Überblick zu bekommen sammelte ich alle möglichen Projektideen und mögliche Umsetzungen in


Zur Versionskontrolle wird während des Projektes für alle Dateien github eingesetzt um jeweils den aktuellen Stand zu protokollieren.



\section{Hardware}
\subsection{Elektronik}
Für die Platine wird Eagle als PCB-Software zum Entwurf der Platine verwendet, da es kostenlos verwendet werden kann und die Platinenentwicklung im Fablab auf Eagle ausgerichtet ist. Das Ziel ist die Platine einlagig aufzubauen. Dies erhöht zwar den Aufwand für das Layout immens, dafür kann aber eine einlagige Platine verwendet werden, die wesentlich einfacher zu entwickeln ist, als eine zweilagige. Auch werden keine Vias in der Platine benötigt, die im Fablab etwas aufwändiger sind. Da der Platz aber durch die Vorgabe der Frontplatte begrenzt ist, müssen auch kleine Bauteile verwendet werden, die etwas aufwändiger zu löten sind.
Versorgt werden soll die LED mittels Strom aus einem USB-Ladegerät oder Computer damit kein besonderes Ladegerät notwenig ist. Dies legt die Versorgungsspannung auf 5 Volt fest. Als Buchse wird eine kombinierte Micro-USB-Buchse die für Stecker des Types A und B geeignet istverwendet. Letzere stellt sicher, dass  die Wordclock an einem handelsüblichen Ladekabel für Handys angeschlossen werden kann.
 Die Hauptarbeit übernimmt dabei ein Prozessor der  Mega8-Reihe von AVR verwendet, da dieser einfach zu programmieren und leicht verfügbar ist. Genau wird der Atmega168PA-PU verwendet, der den größten programmierbaren Flash seiner Baureihe zur Verfügung stellt. Da ein späterer Einbau einer Batteriepufferung möglich sein soll, verwenden wir hier die   Pico-Power Ausführung des AVR, da diese weniger Strom im Schalfmodus verbaucht, was hierbei hilfreich sein kann. Als Baugröße verwende ich hierbei die PDIP  Ausführung . Da bei diesem Gehäuse die Pins nahe beieinander liegen, der AVR gut zwischen der LED-Matrix und dem Rand der Platine eingebaut werden. Hierfür wäre eine andere Gehäuseform zu groß. Zum Programmieren des AVR wird eine Standart ISP-Stecker verwendet, da bereits damit zu rechen ist, das die Software mehrfach aufgespielt werden muss, bis diese reibungslos läuft. 
Die LED-Matrix zum Anzeigen der einzelnen Buchstaben der Matrix werden durch 110 WS2812B LEDs aufgebaut. Diese LEDs haben den Vorteil, dass sie eine eigene Datenleitung haben, und der Mikrocontroller daher nur einen Pin bereitstellen muss, um alle hundertzehn Buchstaben ansteuern zu können. Dies funktioniert, indem ein in die LED eingebauter Chip dieses Datensignal empfängt und über den Data-Out-Pin der LED die folgenden LEDs mit dem Datensignal versorgt. Alle drei Grundfarben können durch den Chip in 255 Stufen bei den LEDs getrennt geregelt werden, damit kann also mit jedem der 110 Buchstaben das gesamte Farbspekrum von 16777216 verschiedenen Farben dargestellt werden. Dem Datenblatt der WS2812B zufolge sollte bei jeder WS2812B ein Kondensator mit 100nF zwischen Versorgungsspannung und Ground im Layout eingebaut werden. Dies dient dazu, die Versorgungsspannung der  LED zu stabilisieren und somit die sicherzustellen, das die Ansteuerung richtig funktioniert. Da für die Versorgung des eingebauten Steuerchips der WS2812B auch im Ausgeschalteten Zustand Strom benötigt wird, kann die Gesamte Matrix über einen P-Kanal-Mosfet von der Versorgungsspannung getrennt werden.Für die LEDs, welche die einzelnen Minuten und den Alarm anzeigen, werden dagegen "normale" LEDs verwendet, deren Kathode vom Mikrocontroller auf Ground gezogen werden können und damit angeschaltet werden. Um keine ungewollten Aktionen beim Programmieren des Atmega auszulösen werden die LEDs auf die selben Pins des Mikrocontroller gelegt, die auch als Verbindung zum In-System-Programmer dienen. Beim Programmieren des AVR kann es also nun vorkommen, dass  die LEDs aktiviert werden, es kann jedoch kein Schaden an Bauteilen erzeugt werden, obwohl diese Pins doppelt genutz werden.
Die Uhrzeit soll sowohl im Mikrocontroller selbst als auch in einem externen Realtime-Clock-Baustein gezählt werden können. Der externe Baustein hat hierbei wieder die Vorteile, dass der Atmega168 im Schlafmodus sein kann und somit wenig Strom benötigt wird. Als Clock-Baustein wird hierfür ein DS1337 verwendet, da dieser zwei externe Interrupt Kanäle besitzt und somit den Mikrocontroller durch einen Alarm aus dem Schlafmodus aufwecken kann. Die Real-Time-Clock wird vom AVR über das Two-Wire Protokoll angesteuert werden.
Für das Einstellen der Uhrzeit und das nutzen anderer Funktionen wie etwa eines Alarms wurden fünf Taster verbaut. Alle diese sind mit einem Kondensator entprellt und jeder Taster ist am AVR angeschlossen, sodass ein Tastendruck mit einem Pin-Change-Interrup detektiert werden kann. 
Außerdem wurde ein LDR (Light Dependent Resistor) also ein Lichtbhäniger Widerstand eingebaut. Somit kann zu einem späteren Zeitpunkt die Helligkeit der Matrix in Abhänigkeit von der Umgebungshelligkeit gesteuert werden kann. So wird sichergestellt, dass die LEDs niemals blenden, was vor allem für den Einsatz als Wecker wichtig ist, aber auch zu jeder Tageszeit gut erkennbar sind.
Damit die Uhr auch in der Lage ist ihre Benutzer zu wecken wurde ein Signalgeber eingebaut, der über einen internen Generator verfügt und somit nicht mit einer Sinusschwingung angeregt werden muss, sondern nur durch anklemmen an die 5V Versorgungsspannung aktiviert werden kann. Dies ist durch den Mikrocontroller wesentlich leichter zu realisieren.
Die zwei nicht  verwendendeten Pins des Atmega wurden auf ein Via an einer freien Stelle der Leiterplatte gelegt, außerdem wurde hier noch ein Via für Ground und +5Volt eingefügt. Somit kann hier zu einem späteren Zeitpunkt einfach eine Lösung zur Spannungsüberbrückung einbaut werden. Diese könnte sogar mit dem AVR kommunizieren und die Wordclock könnte dadurch in einen stromsparenderen Modus wechseln.  

\subsection{Gehäuse}
Um das Gehäuse der Wordclock planen zu können erstelle ich zuerst ein CAD-Modell. Als Programm wurde dafür das SolidWorks verwendet. Dies wurde auch vor dem Hintergrund gemacht, dass die  aus den in Solid Works erstellten Dateien etwa die Schnittmuster für die Zwischenplatte extrahiert werden können. Da Eagle die Möglichkeit besitzt, das Layout der Platine im Intermediate Data Format  (IDF) zu exportieren, welches für den Austausch von Layout und CAD-Programmen gedacht ist, konnte damit in SolidWorks ein genaues 3D Modell erstellt werden. Die einzelnen CAD-Modelle der Bauteile dafür sind im Internet frei verfügbar. Somit konnte anhand der Platine mit den angebrachten Bauteilen ein gutes Gehäuse geplant werden. Für den Prototyp wurde das Gehäuse mit dem Onlinetool "Boxmaker" aus Akryl ausgelasert. Die Zwischenplatte, die dazu dient die einzelnen LEDs gegeneinander abzuschirmen wurde ebenfalls zuerst in SolidWorks erstellt und anschließend mit dem Lasercutter aus einer MDF Platte 
Die Dicke der Zwischenplatte ergibt sich aus dem Abstrahlwinkel der LEDs, dieser beträgt bei den WS2812B 120°. Für die Dicke der Zwischenplatte ergibt sich also mit einer Buchstabengröße von etwa 8mm: 
\begin{equation}
d = \frac{\frac{1}{2} * Buchstabendurchmesser}{tan\frac{120^\circ }{2}}= 4,62
\end{equation}
Aus diesem Grund wurde eine Dicke von 5mm für die Zwischenplatte gewählt.
Zusammengehalten wird die gesamte Uhr von vier M3 Schrauben, welche die Platine, die Zwischenplatte und das Gehäuse mit Abstandshalter fixieren, damit diese nicht verrutschen.

\subsection{Frontplatten}
Für die Frontplatte wurde die Anordnung der Buchstaben in einer Illustrator-Datei erstellt. Dabei wurden alle Buchstaben so angeordnet, dass diese exakt über das entsprechende Loch in der Zwischenplatte passen. Für die erste Anordnung der Buchstaben wurde das selbe Schema, wie es auch bei der Qlocktwo und vielen weiteren Wordclocks im Internet zu finden ist angewendet. Außerdem wurde eine Frontplatte erstellt, die es ermöglicht die Wordclock auch als Binäruhr zu verwenden. Hierfür muss nur die Software entsprechend angepasst werden. Da die Frontplatte idealerweise das licht nur an den Buchstaben das Licht durchlässt und dort leicht milchig sein sollte, gibt es  verschiedene Möglichkeiten zum Erstellen der Platte. Die simpelste Möglichkeit ist dabei, das Layout der Frontplatte auf mehrere Overheadfolien zu drucken und diese mit einem Blatt Papier als Difusor gemeinsam zu lamineren. Problematisch ist hierbei allerdings die Verbindung der einzellenen Folien, da diese sich leicht löst. Bei der binären Frontplatte wurden nur die Lichtdurchlässe aus der Holzplatte ausgeschnitten, die hierfür verwendet wurde. Diese wurden anschließend von hinten mit Papier verklebt, sodass die LEDs durch dieses diffus hindurchleuchten. Als aufwendigste Methode wurde noch eine Akrylscheibe von hinten zuerst farbig und anschließend mehrfach schwarz lackiert aus der das in Illustrator erstellte Frontplattenlayout dann ausgraviert wurde. Die Schwarze Lackierung dient hierbei dazu, dass die LEDs nicht durch die farbigen Stellen der Frontplatte hindurchleuchten. Eine weitere, aber nicht erprobte Methode wäre das Ausschneiden einer Folie mit dem im Fablab verfügbaren Folienplotter und das aufkleben dieser auf eine Milchglasscheibe. Alle Frontplatten sind mit einem Magnet an der Zwischenplatte befestigt, so wird kein Werkzeug zum Austauschen der Zwischenplatte benötigt.
\section{Software}
Die Software für den Atmega168 wurde in Eclipse entwickelt. Der wesentliche Teil der Software ist die Ansteuerung der Matrix der 110 WS2812B LEDs. Dieser funktioniert über ein spezielles Protokoll: die erste LED der Matrix bekommt einen Strom an bits vom Mikrokontroller. Von diesem Bitstrom schneidet die erste LED die ersten 24 bit ab und gibt alle weiteren ankommenden bits an die nächste LED weiter, die nach dem selben Prinzip verfährt. Somit erhält jede LED 24 bit, von denen jeweils 8 die Helligkeit der drei Farben Grün, Rot und Blau repräsentieren.




\section{Ausblick}
DCF
beschriftung der Taster mit Lasercutter
Batterienbetrieben
Da die Buchstaben  einzeln ansteuerbar sind, besteht auch die Möglichkeit die Matrix für noch weitere Anwendungen zu nutzen. So  etwas termeratur anzeigen ; Datum Wochentag etc
%----------------------------------------------------------------------------------------------Ende des eigentlichen Textes

\nocite{*}
%\begin{thebibliography}{1}
%\bibliography{literatur.bib}
%\bibliographystyle{plain}
%\bibitem{IEEEhowto:kopka}
%H.~Kopka and P.~W. Daly, \emph{A Guide to {\LaTeX}}, 3rd~ed.\hskip 1em plus
 % 0.5em minus 0.4em\relax Harlow, England: Addison-Wesley, 1999.

%\end{thebibliography}




% that's all folks
\end{document}


